package cc.tools.activemq.consumer;

import org.apache.activemq.ActiveMQConnectionFactory;

import java.util.concurrent.atomic.AtomicBoolean;

import javax.jms.Connection;
import javax.jms.Destination;
import javax.jms.ExceptionListener;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.MessageConsumer;
import javax.jms.Session;
import javax.jms.TextMessage;

/**
 * This class implements consumer functionality to talk to an ActiveMQ server
 * instance.
 * 
 * @author cc
 * @version %I%, %G%
 * @since 0.1
 */
public class ActiveMQConsumer implements ExceptionListener {

  /**
   * Main method.
   * 
   * @param args program arguments.
   */
  public static void main(String[] args) {
    ActiveMQConsumer.logger().info("running");

    ActiveMQConsumerConfig config = new ActiveMQConsumerConfig(args);

    if (config.getIsHelp()) {
      config.doHelp();
      return;
    }

    if (!config.isValid()) {

      ActiveMQConsumer.logger().error("invalid parameters ",
          config.getErrors().size() +
          " errors");
      
      for (String error : config.getErrors()) {
        ActiveMQConsumer.logger().error("invalid parameters ",
            error);
      }

      return;
    }

    config.doDump();

    ActiveMQConsumer consumer = new ActiveMQConsumer(config);

    if (!consumer.isValid()) {
      ActiveMQConsumer.logger().error("consumer failed to initialise");
      return;
    }

    if (!consumer.readMessagesFromServer()) {
      ActiveMQConsumer.logger().error("send message to server failed");
      return;
    }
    
    ActiveMQConsumer.logger().info("fini");
  }
  
  /**
   * Method sends configured message to the server.
   * 
   * @return boolean value set to true for success, false otherwise.
   */
  private boolean readMessagesFromServer() {
    
    try {
      
      ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory("tcp://localhost:61616");

      Connection connection = connectionFactory.createConnection();
      connection.start();

      Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
    
      Destination destination = null;
      
      if (_config.getTYpe().compareToIgnoreCase("topic") == 0) {

        destination = session.createTopic(_config.getChannel());

      } else if (_config.getTYpe().compareToIgnoreCase("queue") == 0) {
        
        destination = session.createQueue(_config.getChannel());

      } else {
        
        _logger.error("channel type not 'queue' or 'topic'");
        
        return false;
      }
      
      MessageConsumer consumer = session.createConsumer(destination);

      connection.setExceptionListener(this);

      int count = 0;
      
      int limit = _config.getLimit();
      
      while (!_isExit.get()) {

        if (limit != 0 &&
            limit == count) {
        
          _logger.info("limit reached: ",
              limit);

          break;
        }
        
        try {
          
          Message message = consumer.receive(_config.getTimeout());

          if (message instanceof TextMessage) {

            TextMessage textMessage = (TextMessage) message;

            String text = textMessage.getText();

            _logger.info("received: ",
                text);

            count++;
            
          } else if (message == null) {

            //_logger.debug("no message");

          } else {
            
            _logger.info("invalid message");

          }

        } catch (Exception e) {

          _logger.exception(e);

        }
      
      }
      
      connection.close();
      
      session.close();
      
      connection.close();
      
      return true;

    } catch (Exception e) {

       _logger.exception(e);
    
    }
    
    return false;    
  }
  
  /**
   * Method is the exception callback for implemented 
   * Interface {@link ExceptionListener} generated by error
   * in MQ publish framework.
   * @param e exception throw by MQ.
   */
  @Override
  public synchronized void onException(JMSException e) {
  
    _logger.exception(e);
  
    _isExit.set(true);
  }

  /**
   * Constructor {@link ActiveMQConsumer}.
   * 
   * @param config {@link ActiveMQConsumerConfig} object containing program
   *               configuration values.
   */
  public ActiveMQConsumer(ActiveMQConsumerConfig config) {

    _config = config;

    if (_config == null || !_config.isValid()) {
      _logger.error("config not value");
      return;
    }
    
    _isValid = true;
  }
  
  /**
   * Method returns boolean indicating whether {@link ActiveMQConsumer} object is in
   * a valid state.
   * 
   * @return boolean where true indicates {@link ActiveMQConsumer} object is valid,
   *         false otherwise.
   */
  public boolean isValid() {
    return _isValid;
  }
    
  /**
   * Boolean indicating whether this {@link ActiveMQConsumer} object is in a valid
   * state.
   */
  private boolean _isValid = false;

  /**
   * Configuration object containing parameter settings.
   */
  private ActiveMQConsumerConfig _config = null;

  /**
   * Method returns reference to logger object.
   * @return {@link ActiveMQConsumerLogger} logger.
   */
  public static ActiveMQConsumerLogger logger() {
    return _logger;
  }

  /**
   * Local logger reference for logging operations.
   */
  private static final ActiveMQConsumerLogger _logger = new ActiveMQConsumerLogger(ActiveMQConsumer.class.getName());
    
  /**
   * Exit flag.
   */
  private AtomicBoolean _isExit = new AtomicBoolean(false);
}
